
# 📝 C++ Functions – Overloading, Templates, Arguments & Return Types

---

## 🔹 1. Function Overloading

* **Definition**: Same function name, but different **parameter list** (type or number).
* Compiler decides which one to call at compile-time (**compile-time polymorphism**).

### Example:

```cpp
#include <iostream>
using namespace std;

void print(int x) {
    cout << "Integer: " << x << endl;
}

void print(double x) {
    cout << "Double: " << x << endl;
}

void print(string s) {
    cout << "String: " << s << endl;
}

int main() {
    print(10);         // Integer
    print(3.14);       // Double
    print("Hello");    // String
}
```

---

## 🔹 2. Function Template

* Allows writing **generic functions** for multiple types.
* Compiler generates the version depending on the type used.

### Example:

```cpp
#include <iostream>
using namespace std;

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(3, 4) << endl;       // int -> 7
    cout << add(3.5, 2.1) << endl;   // double -> 5.6
    cout << add(string("Hi "), string("There")) << endl; // string
}
```

---

## 🔹 3. Default Arguments

* Parameters can have default values.
* If no argument is provided, default value is used.

### Example:

```cpp
#include <iostream>
using namespace std;

void greet(string name = "Guest") {
    cout << "Hello, " << name << "!" << endl;
}

int main() {
    greet();           // Hello, Guest!
    greet("Bindhu");   // Hello, Bindhu!
}
```

---

## 🔹 4. Passing Arguments

### (a) Pass by Value

* A copy of the variable is passed.
* Changes inside the function **don’t affect original**.

```cpp
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << x << " " << y;  // 5 10 (unchanged ❌)
}
```

---

### (b) Pass by Address (Pointers)

* Address is passed, function operates on memory directly.

```cpp
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(&x, &y);
    cout << x << " " << y;  // 10 5 ✅
}
```

---

### (c) Pass by Reference

* Function receives a reference (`&`).
* Any change directly modifies the original.
* Compiler optimizes: the function code is often **inlined** into main.

```cpp
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << x << " " << y;  // 10 5 ✅
}
```

---

## 🔹 5. Return by Address

* Function returns a **pointer**.
* ⚠️ Should **not return local variable’s address** (it gets destroyed after function ends).
* Safe if returning dynamically allocated memory or static variables.

### Example:

```cpp
int* createArray(int n) {
    int* arr = new int[n];  // dynamic memory
    for (int i = 0; i < n; i++) arr[i] = i;
    return arr;             // safe
}

int main() {
    int* a = createArray(5);
    for (int i = 0; i < 5; i++) cout << a[i] << " ";
    delete[] a; // free memory
}
```

---

## 🔹 6. Return by Reference

* Function returns an actual variable reference.
* Useful for **chaining operations** or **modifying caller’s variable**.
* ⚠️ Must not return reference to a local variable (same reason as above).

### Example:

```cpp
int& getElement(int arr[], int index) {
    return arr[index];   // returning reference
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    getElement(arr, 2) = 99;   // directly modifies arr[2]
    cout << arr[2];            // 99 ✅
}
```

---

# ✅ Summary

* **Overloading** → multiple versions of function.
* **Template** → generic, works with multiple types.
* **Default arguments** → backup values if no args.
* **Pass by Value** → copy (safe, but doesn’t modify).
* **Pass by Address** → pointer, modifies.
* **Pass by Reference** → direct access, modifies.
* **Return by Address** → return pointer.
* **Return by Reference** → return actual variable reference.


static variables - static variables do not get deleted from memory when function exection is done, they exists throughout the code execution just like global variables, but the only difference is they are not accessible everywhere like global variables are.


pointer to a function - 

initialize like void (*fp)();
and then assign fp = display();
and then calling (*fp)();

## 🔹 1. Static Variables

### Concept

* A **static variable inside a function**:

  * Retains its value **between function calls**.
  * Is created only **once** (at program start).
  * Exists until program ends (like a global).
* Unlike globals, its **scope is limited** to the block/function where it is defined.

### Example

```cpp
#include <iostream>
using namespace std;

void counter() {
    static int count = 0;   // initialized once
    count++;
    cout << "Count = " << count << endl;
}

int main() {
    counter();  // Count = 1
    counter();  // Count = 2
    counter();  // Count = 3
}
```

👉 Without `static`, `count` would reset to `0` every time the function is called.

### Uses

* Counting function calls.
* Preserving state between calls.
* Optimizing memory for values that should persist but not be global.

---

## 🔹 2. Pointer to a Function

### Concept

* Functions also have memory addresses.
* We can create **function pointers** to call functions indirectly.
* Useful in:

  * Callback functions.
  * Passing functions as arguments.
  * Implementing event-driven or plugin systems.

---

### Syntax

```cpp
return_type (*pointer_name)(parameter_types);
```

* Example declaration:

  ```cpp
  void (*fp)();   // pointer to function returning void and taking no params
  ```

---

### Example: Assigning & Calling

```cpp
#include <iostream>
using namespace std;

void display() {
    cout << "Hello from display()" << endl;
}

int main() {
    void (*fp)();   // declare function pointer
    fp = display;   // assign function (without ())
    
    // Two ways to call
    (*fp)();  // Hello from display()
    fp();     // Hello from display()
}
```

👉 Note: `fp = display;` (no parentheses) — assigning the function’s **address**, not calling it.

---

### Example: Passing Function as Argument

```cpp
#include <iostream>
using namespace std;

void hello() { cout << "Hello" << endl; }
void bye()   { cout << "Goodbye" << endl; }

void execute(void (*func)()) {
    func();   // call function via pointer
}

int main() {
    execute(hello);   // Hello
    execute(bye);     // Goodbye
}
```

---

# ✅ Summary

* **Static Variables**:

  * Exist for program lifetime.
  * Retain value across function calls.
  * Scope is local, lifetime is global.

* **Function Pointers**:

  * Store addresses of functions.
  * Allow indirect function calls.
  * Commonly used in callbacks & flexible function execution.
