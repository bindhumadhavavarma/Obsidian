
Its generally believed that microkernels are inefficient and less flexible, but the author says its not because of micro kernels but because of improper implementation.

The basic idea of a microkernel is to minimize the kernel part and to implement outside the kernel whatever possible.

The lack of efficiency and flexibility is often said to be because of increased user-kernel mode and address space switches. But it has been shown that things like IPC that are regarded to be the main bottleneck can be built to be way faster (eg the L3 IPC is 22 times faster than the Mach microkenel)

#### **2 What should a Microkernel have?**

The criteria for below primitives is functionality not performance. 
1. we allow something in kernel only if it cannot be implemented outside
2. The target system has to deal with protection
3. hardware implements page based virtual memory.

**Principle of independence** : A process S should not be disturbed or corrupted by another process S'
**Principle of Integrity** : There must be a way for s1 to address s2 and to establish a communication channel which can neither be corrupted nor nor eavesdropped by sâ€™.
#### 2. 1 Address Spaces

At the hardware level, an address space is a mapping which associates each virtual page to a physical page frame or marks it non accessible.

for constructing and maintaining address space on top of the physical address space the microkernel provides 3 operations

1. Grant : The owner of an address space can grant any of its pages (that it has access to) to another space, provided it accepts. The page will be removed from granters space and provided to the grantee's address space.
2. Map : Same as Grant, the only difference is the page will be accessible by both Granter and Grantee.
3. Flush : The owner of an address space can flush any of its pages. after flush all the spaces that received it through grant or map will loose access and only the flusher will be able to access the page.

Mapping and granting copy the pages access right or a subset of them, i.e. can restrict the access but not widen it.

#### 2.2 Threads and IPC
A thread is a activity executing inside an address space. it has a set of registers like stack pointer, instruction pointer and state information. and the state has the address space in which the thread executes. This address space is the reason for having Threads in the kernel. to prevent corruption of address space, all changes to a threads space should be controlled by the kernel.

IPC should also be handled by the microkernel. In IPC the sender decides to send and what to send and the receiver determines if its willing to take the information and interpret it. Therefore ipc is not only the basic concept for communication between systems but together with address spaces it the foundation of independence.

Note that the grant and map operations need IPC since they require an agreement between grand/mapper and the recipient of the mapping.

#### 2.3 Unique Identifiers

a kernel should supply uid for threads or tasks or communication channels. this required for reliable and efficient local communication. for ex if s1 wants to send message to s2, it should know the id of s2 and also s2 should know the id of s1 so that i can make sure the sender is correct/what it expects.

### 3. Flexibility

Memory manager : just a server sitting in the user space that handles the allocation of the physical memory. They can also be stacked where a part of the physical address space is managed by M1 and the other part by m2, now we have two co existing memory managers.

### 4. Performance.

### 5. Non Portability

older microkernels were built on a layer of abstraction to make them easily portable and flexible, but author argues that micro kernels should be processor or hardware dependent to make them faster. Infact he also argues that even the algorithms used inside a m kernel and its internal concepts are highly processor dependent.

### 6. Synthesis, Spin, DP-Mach, Panda, Cache and Exokernel

