
From the implementorâ€™s perspective, file systems deal with how files and directories are **stored**, how **disk space** is managed, and how to ensure **efficiency and reliability**.

---

### ğŸ“ 4.3.1 File-System Layout

File systems are **stored on disks**, often partitioned into **multiple sections**, each holding an independent file system.

---

#### ğŸ–¥ï¸ Legacy BIOS + MBR (Master Boot Record)

- **Sector 0** of the disk is the MBR.
- MBR contains:
  - **Bootloader code**
  - **Partition table** (starting & ending addresses)
  - Marks **one partition as active**
- On boot:
  1. BIOS loads and executes the MBR.
  2. MBR locates the active partition and loads its **boot block**.
  3. Boot block loads the OS.
- **All partitions begin with a boot block**, even if not bootable.

##### ğŸ§± Typical File-System Layout (inside a partition):

```
| Boot Block | Superblock | Free Space Info | I-nodes | Root Dir | Files/Dirs |
```

- **Superblock**: Metadata about the file system (magic number, block count, etc.)
- **Free space management**: Bitmap or free block list
- **I-nodes**: One per file; contains file metadata
- **Root directory**: Entry point for the file hierarchy

---

#### ğŸ’¡ UEFI (Unified Extensible Firmware Interface)

- Successor to BIOS; supports:
  - **Fast booting**
  - **Large disks** (up to 8 ZiB)
  - **Multiple architectures**
- Uses **GPT (GUID Partition Table)** instead of MBR.

##### GPT Details:

- **Block 0**: Reserved for compatibility (legacy MBR marker)
- **Block 1**: Primary GPT header
- **Last block**: Backup GPT
- GPT entries define start and end blocks of each partition

##### EFI System Partition (ESP):

- Uses **FAT file system**
- Contains:
  - Bootloaders
  - Config files
  - Boot-time utilities
- UEFI firmware can **read file systems** and **execute PE (Portable Executable)** files

---

## ğŸ§± 4.3.2 Implementing Files

Implementing file storage requires **tracking which disk blocks** belong to which file. Several strategies exist:

---

### ğŸ“Œ **Contiguous Allocation**

- Each file is stored in a **single sequence** of contiguous disk blocks.
  - e.g., A 50-KB file with 1-KB blocks â†’ 50 continuous blocks.
- **Directory entry** holds:
  - Start block
  - Length (in blocks)

#### âœ… Advantages:
- **Simple implementation** â€“ only two numbers needed.
- **High performance** â€“ only one disk seek required; data can be streamed at full bandwidth.

#### âŒ Disadvantages:
- **External fragmentation**:
  - As files are deleted, gaps (holes) form.
  - Free space is scattered (see Fig. 4-12b).
- **Pre-allocation requirement**:
  - File size must be known in advance to find a hole of suitable size.
  - Impractical for dynamic content like video recording.
- **Compaction** to reclaim space is expensive and rarely done.

---

### ğŸ”— **Linked-List Allocation**

- Each file is a **linked list** of disk blocks.
  - First few bytes of each block store a **pointer** to the next.
  - Only the **starting block** is stored in the directory.
- Blocks need not be contiguous.

#### âœ… Advantages:
- **No external fragmentation** â€“ any free block can be used.
- **Efficient for sequential access.**

#### âŒ Disadvantages:
- **Inefficient random access**:
  - To read block `n`, must traverse blocks `0` to `n-1`.
- **Pointer overhead**:
  - Reduces data space per block.
  - Makes block sizes non-power-of-two, reducing compatibility and performance.
- **Read complexity**:
  - Reading a full data block requires merging content across two blocks due to pointers.

---

### ğŸ” Example (Linked List Storage)

```plaintext
File A:   Block 4 â†’ Block 0 â†’ Block 7 â†’ Block 2 â†’ Block 10 â†’ Block 12
File B:   Block 6 â†’ Block 3 â†’ Block 11 â†’ Block 14
```

Each file block is found by **following the pointer chain** from the first block onward.

---
## ğŸ”— Linked-List Allocation Using a Table in Memory (FAT)

To eliminate the inefficiencies of linked list storage:

- The **pointer word** from each disk block is **moved to an in-memory table**.
- This table is called the **FAT** â€“ *File Allocation Table*.

### ğŸ§  How It Works:
- Each index in the FAT corresponds to a **physical disk block**.
- The entry at that index gives the **next block** in the chain.
- Chains are terminated using a **special marker** (e.g., -1).

#### âœ… Advantages:
- **Entire block is usable** for data (no in-block pointers).
- **Random access is faster** than disk-based linked lists, since the entire chain is in memory.
- Only the **starting block number** is stored in the directory.

#### âŒ Disadvantages:
- **FAT must always remain in memory**.
  - For a 1-TB disk with 1-KB blocks â†’ 1 billion entries.
  - At 4 bytes per entry â†’ 4 GB of RAM needed just for FAT.
- **Scalability problem** for large disks.

> ğŸ” Still used in:
> - MS-DOS
> - Windows (for USBs, SD cards, and UEFI boot partitions)
> - Embedded and portable devices (cameras, music players)

---

## ğŸ“‚ I-nodes (Index Nodes)

Another method of tracking blocks per file is using **i-nodes**.

### ğŸ“Œ What is an I-node?
An i-node is a per-file **data structure** containing:
- File metadata (attributes)
- Disk addresses of file blocks

#### ğŸ“¦ Structure:
```text
I-node:
â”œâ”€â”€ File Attributes
â”œâ”€â”€ Address of block 0
â”œâ”€â”€ Address of block 1
â”œâ”€â”€ ...
â””â”€â”€ Address of block n
```
If file size exceeds the space available for direct block pointers:
- The **last pointer** references a **block of pointers** (indirect block).
- This can be extended to **double** or **triple indirect blocks** for very large files.

### âœ… Advantages:
- **Only loaded in memory when file is open**.
- Memory usage is proportional to **number of open files**, not total disk size.
- **Scales well** for large disks (unlike FAT).

### âŒ Disadvantages:
- **Fixed number of direct block pointers**.
  - Requires extra logic to handle large files using indirect blocks.

---

### ğŸ†š FAT vs I-nodes Summary

| Aspect             | FAT                          | I-node                          |
|--------------------|-------------------------------|----------------------------------|
| In-memory size     | Proportional to disk size     | Proportional to open files       |
| Random access      | Fast (in memory)              | Needs i-node traversal           |
| Scalability        | Poor for large disks          | Good scalability                 |
| Used in            | MS-DOS, Windows, UEFI, SD     | UNIX, Linux, MacOS, NTFS        |
| Directory entry    | Holds starting block only     | Points to the i-node             |

---
## ğŸ—‚ï¸ 4.3.3 Implementing Directories

### ğŸ“Œ Directory Lookup Basics
- Directories map **file names (ASCII)** to **metadata needed to locate data blocks**:
  - Contiguous allocation â†’ starting disk address.
  - Linked-list â†’ pointer to first block.
  - I-node based â†’ i-node number.

### ğŸ“‚ Attribute Storage Methods
- **In-directory storage**: Each directory entry stores file name, attributes, and block addresses.  
  â†’ Used in simpler systems.  
- **I-node-based storage**: Directory entries store only file name + i-node number.  
  â†’ Attributes live inside the i-node.  
  âœ… Easier updates, better modularity.

### ğŸ”  Handling Long File Names

#### (a) **Inline variable-length entries**
- Each entry has:
  - Length field
  - Attributes
  - File name (terminated with 0 and padded)
- âŒ Causes internal fragmentation and gaps on deletion.

#### (b) **Fixed-length entries + Heap**
- Directory entries contain:
  - Attributes
  - Pointer to file name in a separate heap.
- âœ… Easier reuse of freed entries.
- âŒ Adds heap management complexity.

### ğŸš€ Fast Directory Lookup

#### ğŸ” Linear Search (default)
- Simple, used in small/medium directories.
- Slower for directories with many files.

#### ğŸ”¢ Hash Table Lookup
- File names are hashed to speed up lookup.
- Entry points to chain of same-hash entries.
- âœ… Very fast for large directories.
- âŒ Complex management.

#### ğŸ“¥ Caching
- Recently looked-up file names are cached.
- Useful if most lookups hit a small subset of files.

---

## ğŸ” 4.3.4 Shared Files

### ğŸ“ Why Share Files?
- Users collaborating on a project often need access to the same files.
- A **shared file** can appear in multiple directories.

### ğŸŒ³ File System Becomes a DAG
- Sharing turns the file tree into a **Directed Acyclic Graph (DAG)**.
- Example: File appears in both user Bâ€™s and Câ€™s directories.

---

### ğŸ”— Hard Links
- Directory stores pointer to the same i-node.
- **Link count** in the i-node tracks number of directory entries.
- âœ… Efficient, no extra file created.
- âŒ Ownership and deletion are tricky:
  - If C deletes the file, B still has access.
  - C remains owner and gets billed.

---

### ğŸ”— Symbolic Links (Soft Links)
- Bâ€™s directory stores a **new file of type LINK**, containing the path to Câ€™s file.
- âœ… If original is deleted, symbolic link fails gracefully.
- âœ… Can point across disks or machines.
- âŒ Slower: needs extra I/O and i-node.
- âŒ Extra i-node and block needed.

---

### âš ï¸ Link-Related Issues

| Issue                          | Hard Link                  | Symbolic Link                 |
|-------------------------------|----------------------------|-------------------------------|
| File removed by owner         | File survives (link count) | Link breaks (path not found) |
| Ownership tracking            | Remains with original user | Not a concern                 |
| Works across devices/networks | âŒ No                      | âœ… Yes                        |
| Disk space                    | Shared                     | Needs extra i-node + block    |
| Multiple path problems        | Both can cause duplication in backups, directory crawls, etc. |

---

