
## ğŸ§© 3.5.5 Separate Instruction and Data Spaces

---

### ğŸ§  Unified Address Space: Default Model

- Most systems have a **single virtual address space** for both:
  - **Program (code)**  
  - **Data (stack, heap, etc.)**
- Works well if space is large enough  
- Can be limiting on smaller architectures (e.g., 16-bit systems)

---

### ğŸ”€ Split I- and D-Spaces (I-space & D-space)

- Pioneered on **PDP-11**
- Separate virtual spaces for **instructions** and **data**
  - Each has its own page table
  - Code & data mapped independently

---

### âœ… Benefits

- **Doubles available virtual memory**
- Cleaner **sharing** of code among processes
- Still used in **L1 caches** and **TLB partitions** today

---

## ğŸ¤ 3.5.6 Shared Pages

---

### ğŸ“š Why Share?

- Multiple users may run the **same program** or use the **same library**
- Avoids having **duplicate pages** in memory

---

### ğŸ§¾ Code Sharing

- Easier if **separate I- and D-spaces** exist:
  - Processes point to **same I-space page table**
  - Have **independent D-space tables**

- OS uses data structures to track shared pages (to avoid scanning all page tables)

---

### âš ï¸ Challenges

- If process A is evicted, and it **shares pages with B**,  
  â†’ B may face a **flood of page faults** to reload shared pages

- When A terminates, OS must **retain shared pages** still in use

---

### âœ‚ï¸ Copy-On-Write (COW)

Used after **`fork()`** in UNIX-like systems:

1. Parent & child **share pages**, all marked **READ ONLY**
2. On **write attempt**, trap triggers:
   - OS **copies the page**
   - Updates mapping to allow **READ/WRITE**
3. âœ… No need to copy unmodified pages

> ğŸ“ˆ Great for performance: minimizes unnecessary duplication

---

## ğŸ“š 3.5.7 Shared Libraries

---

### ğŸ§© Why Share Libraries?

- Avoids bloating binaries
- Saves **RAM + nonvolatile storage**
- Supports **dynamic updates**

---

### ğŸ› ï¸ Linking: Static vs Shared

| Type | Description |
|------|-------------|
| **Static Linking** | All required functions copied into the binary |
| **Shared Libraries** | Use **stubs** that bind at runtime (like DLLs on Windows) |

> Shared libraries are **paged in on demand**, saving memory.

---

### ğŸ›¡ï¸ Auto Updates

- Fixes in shared libraries (e.g., via **Windows Update**) automatically benefit **all programs** using them

---

### ğŸ§  Key Issue: Address Relocation

- Shared libraries may be **mapped at different virtual addresses** in each process
- Absolute address jumps would break

---

### âœ… Solution: Position-Independent Code (PIC)

- Use **relative addressing only**
- Compilers use flags to **generate relocatable code**
- Ensures that shared code runs correctly **regardless of load address**

---

## ğŸ—‚ï¸ 3.5.8 Memory-Mapped Files

---

### ğŸ’¾ Concept

- A file is **mapped** into a processâ€™s **virtual address space**
- Pages loaded on demand (just like paging)
- **Backed by the file** instead of swap/disk

---

### ğŸ“œ Benefits

- Simpler I/O model:
  - File access becomes like working with **memory arrays**
- Automatic page loading, **write-backs on exit/unmap**

---

### ğŸ”„ Interprocess Communication (IPC)

- Two processes can **map the same file**:
  - Write by one â†’ Read by the other
  - **High-bandwidth shared memory channel**
- Common trick: use **temporary files** for this mapping

---

### âœ… Applications

- Underlies the implementation of **shared libraries**
- Ideal for:
  - Caching
  - DB memory access
  - Large file processing
