
### ‚ö†Ô∏è The Problem

When a **page fault** occurs, the OS must **evict** a page to make space for the new one:
- If the page was **modified** (dirty), it must be **written back** to disk or SSD.
- If it was **clean** (unchanged), it can be simply **overwritten**.

> ‚ùå Evicting a heavily used page leads to frequent reloads and degrades performance.

---

### üåç Similar Problems in Other Domains

- **Memory Caches**: CPU caches also replace 32- or 64-byte blocks on a smaller time scale.
- **Web Servers**: Web caches evict rarely accessed pages, but web pages aren‚Äôt modified (always clean).
- **Design Analogy**: The page replacement problem appears across systems, varying in scale and volatility.

---

### üîÄ Per-Process vs Global Replacement

- Should the page to be evicted belong only to the **faulting process**, or can it come from **any process**?
- We'll revisit this question in **Section 3.5.1**.

---

## üèÜ 3.4.1 The Optimal Page Replacement Algorithm

---

### üß† Key Idea

Evict the page that will be **used farthest in the future**.

> If page A is needed in 8M instructions and B in 6M, evict A.

---

### üìâ Why It's Not Practical

- OS can't predict **future page references**.
- It's only usable in **simulations** for benchmarking.

---

### üß™ How It‚Äôs Used

- **Simulate a run** and log all memory accesses.
- **Second run** uses the log to simulate optimal replacement.
- Useful for comparing real algorithms' performance to theoretical best.

---

## üßÆ 3.4.2 The Not Recently Used (NRU) Algorithm

---

### üõ†Ô∏è Mechanism

Uses two **status bits** per page:
- `R` (Referenced): Set when the page is accessed.
- `M` (Modified): Set when the page is written to.

These bits are **hardware-maintained**, or simulated by OS via **page faults and clock interrupts**.

---

### üî¢ Classification

Pages are periodically classified into four categories:

| Class | Referenced (R) | Modified (M) | Description |
|-------|----------------|--------------|-------------|
| 0     | 0              | 0            | Not used or changed |
| 1     | 0              | 1            | Modified long ago |
| 2     | 1              | 0            | Recently read |
| 3     | 1              | 1            | Recently written |

> Clock interrupts **clear R**, not M. That‚Äôs how Class 1 can exist.

---

### üìå Algorithm

- Evict a page at random from the **lowest-numbered non-empty class**.
- Goal: Prefer removing **old, unreferenced, or less valuable** pages.

---

### ‚úÖ Pros

- **Simple and efficient**
- Provides **reasonable performance**
- Doesn't require keeping full history

---

## üßæ 3.4.3 The FIFO (First-In, First-Out) Algorithm

---

### üõçÔ∏è Supermarket Analogy

Imagine a store with space for `k` products. A new product arrives:
- Remove the one added **longest ago**.
- Might remove **something useful** just because it‚Äôs old.

---

### üñ•Ô∏è OS Implementation

- Maintain a **linked list** of pages in memory.
- On page fault:
  - Remove the **head** (oldest page).
  - Insert new page at the **tail**.

---

### ‚ö†Ô∏è Problem

- FIFO may evict **frequently-used** but old pages.
- Example: Removing **butter** from a store shelf just because it‚Äôs old.

---

### üö´ Usage

- **Rarely used in pure form** due to risk of evicting essential pages.
- Often improved with additional **reference tracking**.

Here‚Äôs a fully styled, icon-enhanced, Obsidian-friendly summary for **Section 3.4.4‚Äì3.4.10 ‚Äì Page Replacement Algorithms (Continued)**:

---

## üîÑ 3.4.4 Second-Chance Page Replacement

---

### üí° Core Idea

A **refined FIFO** that gives each page a "second chance" if it's been recently used.

---

### üõ†Ô∏è How It Works

1. Inspect the **oldest page** (head of FIFO list).
2. If `R = 0`: Page is old & unused ‚Üí **Evict it**.
3. If `R = 1`:  
   - Clear `R`,  
   - **Move page to end** of list (as if it just arrived),  
   - Continue search.

---

### üìä Illustration

Imagine pages A‚ÄìH in a FIFO queue.  
At time `t=20`, if A has `R=1`, it is recycled to the end with updated load time.  
Search continues with B, and so on.

---

### ‚úÖ Pros

- Avoids evicting **frequently used** pages.
- Degenerates into **FIFO** if all pages are referenced.

---

## üï∞Ô∏è 3.4.5 Clock Page Replacement

---

### ‚è∞ Optimization of Second-Chance

Avoids moving pages around by organizing them in a **circular list (clock)**.

---

### üõ†Ô∏è Operation

- On **page fault**, check page pointed by the hand:
  - `R = 0`: **Evict** it.
  - `R = 1`: Clear `R`, advance hand.

üîÅ Repeat until a page with `R = 0` is found.

> More efficient than Second-Chance due to reduced memory operations.

---

## üìâ 3.4.6 Least Recently Used (LRU)

---

### üí° Concept

Evict the page that was **unused for the longest time**‚Äîa realistic approximation of the **optimal** strategy.

---

### ‚öôÔ∏è Full LRU Requires:

- A **linked list** of pages ordered by usage.
- Updating list on **every memory access**.

> ‚ùó Very **expensive to implement**, even with hardware.

---

### üßÆ Hardware-Based Approximation

- Use a **64-bit counter C** incremented per instruction.
- Each page stores the **last value of C** when referenced.
- On fault, evict page with **smallest counter** (least recently used).

---

## üß† 3.4.7 Simulating LRU in Software

---

### üêò NFU ‚Äì Not Frequently Used

- Each page has a **software counter**.
- On every **clock tick**:
  - Add `R` bit to counter.
- On fault, evict page with **lowest count**.

> üîª Downside: Remembers **too far back** (never forgets).

---

### üîÅ Aging Algorithm (Improved NFU)

1. On every clock tick:
   - Shift counter **right by 1**.
   - Insert `R` bit at **leftmost position**.
2. Clear `R`.

---

### üß™ Example Behavior

Over 5 clock ticks:
- Recently used pages have higher binary values.
- Older pages accumulate leading zeroes ‚Üí **more likely to be evicted**.

> ‚úÖ Efficient, good **LRU approximation**, works with limited bits.

---

## üß≥ 3.4.8 Working Set Algorithm

---

### üîç Core Idea

Only keep the **pages a process is actively using**‚Äîits **working set**.

---

### üßæ Definitions

- **Working set** `w(k, t)`: Set of pages used in the **last `k` memory refs** (or `Œî` time).
- **Thrashing**: Excessive faults due to missing working set.

---

### üõ†Ô∏è How It Works

1. Keep a **time-of-last-use** per page.
2. On page fault:
   - If `R = 1`: update time-of-last-use.
   - If `R = 0`:
     - If age > `Œî`: **Evict** (not in working set).
     - Else: track as least recently used clean page.
3. If no pages can be evicted, choose a **clean page**, or pick one at random.

---

### üîÅ Practical Approximation

Instead of tracking k memory refs, use a **time window** (e.g., 100ms of **virtual time**).

---

## ‚è±Ô∏è 3.4.9 WSClock Algorithm

---

### üß≠ Hybrid of Working Set + Clock

Efficient, practical algorithm combining **clock-style traversal** with **working set logic**.

---

### üõ†Ô∏è Algorithm Overview

1. Pages in a **circular list** with:
   - `R` bit
   - `Time of last use`
   - `M` bit (not shown)

2. On fault, scan like clock:
   - `R = 1`: clear it, move on.
   - `R = 0`:
     - If **clean** and **age > Œî** ‚Üí Evict.
     - If **dirty** ‚Üí schedule write, move on.

3. After full sweep:
   - If writes were scheduled ‚Üí wait for one to complete.
   - If no writes ‚Üí evict **any clean page**.

---

### ‚úÖ Advantages

- Avoids full table scan.
- **Efficient**, widely used in real-world OSs.

---

## üßæ 3.4.10 Summary of Algorithms

---

| Algorithm | Description | Remarks |
|----------|-------------|---------|
| **Optimal** | Evict page used farthest in future | Theoretical benchmark only |
| **NRU** | Four classes via R/M bits | Easy but crude |
| **FIFO** | Remove oldest page | Can evict important pages |
| **Second Chance** | FIFO + R bit check | Major improvement |
| **Clock** | Circular Second Chance | More efficient |
| **LRU** | Evict least recently used | Great but needs special hardware |
| **NFU** | Software approximation of LRU | Remembers too much |
| **Aging** | Time-decaying NFU | Efficient LRU approximation |
| **Working Set** | Pages in recent use window | Accurate but costly |
| **WSClock** | Working Set + Clock | Best balance of performance & cost |

---

### üèÅ Final Takeaways

- **Aging** and **WSClock** are the best **pure algorithms**.
- OSs use **custom hybrids** depending on workload and hardware.
  - **Windows** blends Clock, Working Set.
  - **Linux** uses **split LRU lists** for file-backed vs anonymous pages.

---

