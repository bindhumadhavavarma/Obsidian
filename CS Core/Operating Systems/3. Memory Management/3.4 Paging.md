---

### üß† Section 3.3 ‚Äì Virtual Memory

---

#### üîπ Motivation for Virtual Memory

While **base and limit registers** provide address space abstraction, they fall short when dealing with modern software demands:

- Software (especially bloatware) grows faster than physical memory.
- Early systems like VAX ran dozens of users on 4 MB; modern Windows 10 recommends 2 GB minimum for a single user.
- **Swapping entire programs** in/out of memory becomes inefficient with large applications (e.g., 1-GB app takes multiple seconds to swap on a hard disk).
- Even SSDs, though faster, impose substantial delays.

> There‚Äôs a need to **run programs larger than memory** and **support many concurrent programs**, even if they collectively exceed available RAM.

---

#### üîπ Historical Solution: Overlays

- Programs were **manually divided into overlays** (small pieces).
- Only one or a few overlays were kept in memory at any time.
- The **overlay manager** loaded overlays as needed, replacing previous ones.
- Overlays resided on nonvolatile storage (disk/SSD).
- **Problem**: Overlay division was done **manually by programmers**, a slow, error-prone task.

---

#### üîπ Enter Virtual Memory (Fotheringham, 1961)

Virtual memory automates what overlays tried to do‚Äîdynamically load only needed parts of a program.

##### üìå Core Idea:

- Each program gets a **virtual address space**, divided into chunks called **pages**.
- **Pages** are mapped to physical memory by the **Memory Management Unit (MMU)**.
- Not all pages need to be in memory at once:
  - If a page is not present ‚Üí **page fault** ‚Üí OS brings the page in from disk ‚Üí instruction is retried.

##### üìå Analogy:

> Virtual memory is a generalization of base/limit registers, where the **entire address space** is **mapped in small chunks** (pages), not just text or data segments.

---

### üîπ Virtual Memory + Multiprogramming

- Works well with **multiprogramming**:
  - Parts of different programs can be loaded simultaneously.
  - While one process waits for pages, another can use the CPU.

---

### 3.3.1 ‚Äì Paging

---

#### üî∏ What Is Paging?

- **Paging** is the most common virtual memory implementation today.
- It divides:
  - **Virtual address space** into **pages**.
  - **Physical memory** into **page frames** (same size as pages).
- **Pages and page frames are mapped** via a structure called the **page table**.

---

#### üî∏ Virtual Address vs Physical Address

- Instruction: `MOV REG,1000` ‚Üí accesses virtual address 1000.
- Without virtual memory: this goes directly to physical address 1000.
- With virtual memory:
  - Address 1000 is first sent to the **MMU**.
  - MMU maps it to an appropriate **physical address**.

---

#### üî∏ Example Setup (Fig. 3-9):

- Virtual address space: **16-bit** ‚Üí 64 KB total ‚Üí **16 pages** of 4 KB each.
- Physical memory: **32 KB total** ‚Üí **8 page frames** of 4 KB each.
- Page table defines which **virtual page** maps to which **physical page frame**.

---

#### üî∏ How Mapping Works:

- Virtual address 0 (in page 0) ‚Üí MMU maps it to **physical frame 2** ‚Üí becomes address 8192.
- Virtual address 8192 (page 2) ‚Üí mapped to **frame 6** ‚Üí becomes 24576.
- Virtual address 20500 (in page 5) ‚Üí maps to frame 3 ‚Üí becomes 12288 + offset 20 = 12308.

---

#### üî∏ Handling Page Faults

If a virtual page is **not mapped** (e.g., page 8), accessing it (e.g., address 32780) causes:

1. **MMU traps to OS** ‚Üí page fault.
2. OS:
   - Chooses a **victim page** (e.g., frame 1).
   - Writes it to disk (if modified).
   - Loads the **missing virtual page (e.g., 8)** into freed frame.
   - Updates the **page table**.
3. Trapped instruction is **re-executed**.

> After loading, address 32780 (offset 12 into page 8) is mapped to 4096 + 12 = **4108**.

---

### üî∏ Why Use Power-of-Two Page Sizes?

- Simplifies MMU logic.
- Virtual address split into:
  - **Page number** (high bits)
  - **Offset within page** (low bits)
![[{9A02F5C2-75E4-4DB4-B0F1-A1F5C90A829D}.png]]
#### Example (Fig. 3-10):

- 16-bit virtual address: `8196 = 0010000000000100`
  - **Page number** (4 bits): `0010` ‚Üí Page 2
  - **Offset** (12 bits): `000000000100` ‚Üí 4
- MMU:
  - Looks up page 2 ‚Üí finds frame 6.
  - Computes physical address: `frame 6 base (24K) + offset (4)` = **24580**

---

### üî∏ Scaling to Modern Systems

#### üìå 32-bit Systems:

- 4 KB page size ‚Üí needs **2¬≤‚Å∞ (1 million+) page table entries**.
- Manageable with large RAM.

#### üìå 64-bit Systems:

- 4 KB page size ‚Üí would require **2‚Åµ¬≤ (~4.5 quadrillion) entries** ‚Üí **impractical**.

> ‚ö†Ô∏è More advanced memory management techniques (e.g., multi-level page tables, inverted page tables) are needed for 64-bit virtual memory. These will be discussed later.

---

### ‚úÖ Summary

- Virtual memory allows programs to **use more memory than physically available** by loading pages on demand.
- **Paging** breaks up virtual and physical memory into fixed-size chunks.
- **MMU** handles address translation and enforces memory protection.
- **Page faults** trigger the OS to bring in missing pages from disk.
- Power-of-two page sizes make MMU hardware simpler and faster.
- Modern systems need **efficient data structures** to scale page tables to large address spaces.

---