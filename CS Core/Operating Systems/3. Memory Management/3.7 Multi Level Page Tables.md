---

### ðŸ§  Section 3.3.4 â€“ Page Tables for Large Memories

---

While **TLBs help speed up** paging, they donâ€™t solve the issue of **scaling page tables** to extremely large virtual address spaces. Two main solutions have emerged to handle this:

---

## ðŸ”¹ 1. Multilevel Page Tables

---

### ðŸ”¸ Problem Recap

- A **32-bit address space** with 4-KB pages requires 2Â²â° = **1 million page table entries**.
- For **64-bit systems**, this skyrockets to **billions/trillions of entries**.
- Storing huge page tables in memory for every process is **wasteful**, especially when large address chunks are unused.

---

### ðŸ”¸ Multilevel Paging Concept

Rather than having a flat page table, split it into **levels** to avoid storing unused sections.

#### ðŸ§± Example: Two-Level Page Table (Fig. 3-13)

- **Virtual address (32-bit)** split as:
  - PT1 (10 bits) â†’ Index into **top-level page table** (1024 entries)
  - PT2 (10 bits) â†’ Index into **second-level page table**
  - Offset (12 bits) â†’ Byte offset within the 4-KB page

> The **top-level page table** maps **4 MB chunks** of the virtual address space.  
> Each second-level page table maps individual 4-KB pages within its chunk.

---

### ðŸ§ª Example Walkthrough:

**Address**: `0x00403004` (decimal: 4,206,596)  
- PT1 = 1 â†’ Refers to 4Mâ€“8M region (data)  
- PT2 = 3 â†’ Selects 3rd page (within 4Mâ€“8M chunk)  
- Offset = 4 â†’ Byte 4 of the page  

**Steps:**
1. PT1 = 1 â†’ Index top-level page table â†’ get 2nd-level page table for data.
2. PT2 = 3 â†’ Index second-level page table â†’ get page frame number.
3. Combine with offset â†’ physical address.

---

### âœ… Benefits:

- Unused portions of the virtual address space **donâ€™t need page tables**.
- If a process uses only a few address regions (e.g., code, data, stack), only **those second-level tables** need to exist.
- Reduces memory usage significantly.

---

### ðŸ” Extending to More Levels

- Intel x86 paging evolved over time:
  - **80386**: 2-level paging (page directory + page table)
  - **Pentium Pro**: 3-level paging (added "page directory pointer table")
  - **x86-64 (AMD64)**: 4-level paging (â€œPage Map Level 4â€ or **PML4**)
    - Each level uses 9 bits â†’ 512 entries per table
    - Supports **48-bit addresses** = **256 TB of addressable space**
  - **5-level paging** (newer CPUs): supports **57-bit virtual addresses** = **128 PB**

> ðŸ§  More levels = better scalability but **slower page walks**

---

## ðŸ”¹ 2. Inverted Page Tables

---

### ðŸ”¸ Basic Concept

- Flip the model: instead of one entry **per virtual page**, have one entry **per physical page frame**.

#### ðŸ“¦ Each entry stores:
- `(Process ID, Virtual Page Number)` â†’ identifying which process and virtual page currently uses that frame.

#### ðŸ“‰ Example:
- 16 GB RAM with 4-KB pages â†’ 4M entries in the inverted page table.
- This is much smaller than billions of virtual page entries in 64-bit space.

---

### ðŸ”¸ Benefit

- **Space-efficient**: Especially in 64-bit systems with sparse address usage.

---

### ðŸ”¸ Problem: Lookup is Harder

To translate a virtual address:
- Must **search the inverted page table** for a matching `(Process, VPN)` pair.
- Cannot use VPN as an index anymore.
- Searching 1M+ entries for **every memory access** is **too slow**.

---

### ðŸ”¸ Solution: Use TLB + Hash Table

- **TLB** still caches the most frequently accessed pages.
- On **TLB miss**, OS uses a **hash table** to quickly search the inverted table:
  - Hash on VPN â†’ short linked list (chained)
  - Reduces average search time to a few comparisons

> Once mapping is found, it's reloaded into the TLB.

---

### ðŸ“Š Comparison (Fig. 3-14)

| Traditional Page Table | Inverted Page Table |
|------------------------|---------------------|
| 1 entry per virtual page | 1 entry per physical frame |
| Fast lookup (index by VPN) | Slow unless hash used |
| Huge size in 64-bit space | Compact |
| Separate table per process | Global table with process ID |

---

### ðŸ§  Summary of Page Table Strategies

| Strategy | Main Idea | Pros | Cons |
|----------|-----------|------|------|
| **Flat page table** | One-level array | Simple | Huge for large address spaces |
| **Multilevel page table** | Split into hierarchy | Space-efficient | Slower page walks |
| **Inverted page table** | One entry per physical frame | Very compact | Slow lookups; needs hashing |
| **TLB** | Cache recent mappings | Fast | Small capacity |

---

### âœ… Key Takeaways

- **Multilevel paging** helps manage sparse virtual address usage efficiently.
- **Inverted page tables** are space-saving for large address spaces but need hashing for speed.
- **TLBs remain essential** to avoid frequent memory references.
- As address spaces grow (57+ bits), **hierarchies deepen**, and hardware + OS must adapt.

--- 
