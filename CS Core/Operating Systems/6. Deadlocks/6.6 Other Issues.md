## üîç 6.7 Other Issues in Deadlocks

---

### üîê 6.7.1 Two-Phase Locking

> Used in **databases** to avoid deadlock when multiple records must be locked.

#### üõ† How It Works:
- **Phase 1 (Locking phase):**
  - Attempt to acquire all needed locks.
  - If any lock is unavailable ‚Üí **release all locks**, wait, and restart.
- **Phase 2 (Working phase):**
  - Once all locks acquired ‚Üí update records and release locks.

#### ‚úÖ Advantages:
- Prevents deadlocks if all locks are acquired before any work starts.

#### ‚ùå Limitations:
- Not suited for:
  - Real-time or control systems.
  - Operations with non-reversible side effects (network writes, file updates).
- Only effective if restart is safe and application is carefully designed.

---

### üì° 6.7.2 Communication Deadlocks

> Deadlock without resources ‚Äî arises from **blocking message-based interactions**.

#### ‚ö†Ô∏è Scenario:
- Process A sends a request to B, waits for reply.
- B waits for request to act ‚Üí **both are blocked**.

#### üß© Key Characteristics:
- **No resources involved** ‚Üí cannot use resource-ordering to prevent.
- Matches formal definition of deadlock: each waits for event only the other can trigger.

#### ‚úÖ Solution:
- **Timeouts:** resend if no reply within expected time.
  - Risk: if reply was just delayed, **duplicate actions** may occur (e.g., duplicate payments).
- Requires **careful protocol design** (e.g., idempotent operations).

#### üîÑ Communication & Resource Deadlocks:
- Network routers with full buffers can cause classical **resource deadlocks**.
  - Circular wait of full buffers leads to **packet delivery freeze**.

---

### üí´ 6.7.3 Livelock

> Processes continuously retry resource acquisition, **but make no progress**.

#### ‚öôÔ∏è How It Happens:
- Polite processes release locks when they can't acquire others, then retry.
- If all processes do this simultaneously ‚Üí infinite retries, **no blocking, no progress**.

#### üîÅ Example:
```c
while (try_lock(R2) == FAIL) {
  release(R1);
  wait();
  acquire(R1);
}
```

- Like two people stepping side-to-side forever trying to pass each other.

#### Other Livelock Examples:
- Fork fails due to full process table, process retries in a loop ‚Üí livelock.
- Inode table, swap space ‚Üí same issue with other kernel-limited resources.

#### üìå Tradeoff:
- Users prefer flexibility (many files, processes) even at **rare cost of livelocks**.
- Prevention strategies would **over-restrict users**.

---

### üö´ 6.7.4 Starvation

> A process is **indefinitely denied** access to a resource it needs.

#### ‚ö†Ô∏è Cause:
- Resource allocation policies that **favor short jobs** or frequent requests.
  - Ex: Printer always given to shortest job ‚Üí large jobs starve.

#### ‚úÖ Prevention:
- **First-Come, First-Served (FCFS):**
  - Ensures eventual access for all.

#### ‚ùó Controversy:
- Some equate starvation with deadlock (no progress in both).
- Others differentiate:
  - Starving process *could* try alternate strategies.
  - Deadlocked process is completely blocked.

---

## üß† Summary

| Problem         | Key Feature                                  | Common Fix             |
|----------------|-----------------------------------------------|------------------------|
| Two-Phase Locking | Acquire all locks before action             | Retry on failure       |
| Communication Deadlock | Processes wait on each other without resources | Use timeouts           |
| Livelock        | No progress despite constant retrying         | Add randomness, backoff |
| Starvation      | Process indefinitely postponed                | Use fair scheduling    |

---

