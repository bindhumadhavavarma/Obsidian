
### ðŸ§­ Core Idea
- Unlike prevention or avoidance, this strategy:
  - **Allows** deadlocks to occur
  - **Detects** them after they happen
  - **Recovers** the system from the deadlocked state

---

## ðŸ” 6.4.1 Deadlock Detection (Single Resource of Each Type)

---
![[{84099617-5F5F-4E8A-8FEC-074AD5543DEB}.png]]
### ðŸ§± Problem Setup
- One instance of each resource (e.g., 1 printer, 1 scanner)
- Each resource can be held by only **one process** at a time

#### ðŸ§ª Example
Resources: R, S, T, U, V, W  
Processes: Aâ€“G

| Process | Holds      | Requests       |
|---------|------------|----------------|
| A       | R          | S              |
| B       | â€”          | T              |
| C       | â€”          | S              |
| D       | U          | S, T           |
| E       | T          | V              |
| F       | W          | S              |
| G       | V          | U              |

#### ðŸ” Cycle in Graph
- A cycle â†’ **Deadlock**
- Cycle in this case: `D â†’ T â†’ E â†’ V â†’ G â†’ U â†’ D`
- So, processes **D, E, and G** are deadlocked

---

### ðŸ“Š Graph-Based Detection

- **Graph Structure:**
  - **Circles** = Processes
  - **Squares** = Resources
  - **Arrows**:
    - From **process to resource** â†’ waiting
    - From **resource to process** â†’ held by

#### âœ… No cycle â†’ No deadlock  
#### âŒ Cycle â†’ Deadlock involving all members in the cycle

---

### ðŸ§  Simple Cycle Detection Algorithm

1. For each **node N** in the graph:
2. Initialize **list L** (empty) and mark all arcs as unvisited.
3. Add **N to L**, check if it appears twice â†’ **Cycle found**
4. If **N** has unvisited outgoing arcs:
    - Mark one, follow it â†’ go to step 3.
5. If **no arcs** â†’ backtrack to previous node.
6. If **root node is reached with no cycle** â†’ no deadlock for that root.

> Performs a **depth-first search** to find cycles  
> Stops immediately when a cycle is found

---

### ðŸ§ª Example Walkthrough (Simplified)

Start at `B â†’ T â†’ E â†’ V â†’ G â†’ U â†’ D â†’ T`  
â†’ T already in the path = **Cycle detected**  
â†’ Deadlock between **D, E, G**

---

### âš ï¸ Notes

- Algorithm shown is **not optimal**, but **conceptually important**
- Better algorithms exist (e.g., Even 1979), but this illustrates the **principle** well

---
## ðŸ” 6.4.2 Deadlock Detection: Multiple Resource Instances

---

### ðŸ“¦ Problem Context

When systems have **multiple instances** of resources (e.g., 3 printers, 2 scanners), we need a **matrix-based algorithm** to detect deadlocks across `n` processes and `m` resource types.

---

### ðŸ§® Data Structures

- **E** = Existing resource vector  
  `E[i]`: Total number of instances for resource type `i`

- **A** = Available resource vector  
  `A[i]`: Number of currently *unallocated* instances of resource `i`

- **C** = Current Allocation Matrix (`n Ã— m`)  
  `C[i][j]`: # of instances of resource `j` *held* by process `i`

- **R** = Request Matrix (`n Ã— m`)  
  `R[i][j]`: # of instances of resource `j` *requested* by process `i`

> ðŸ§  **Invariant**:  
> For each resource type `j`:  
> `sum(C[i][j] for i in 1..n) + A[j] = E[j]`  
> â†’ All resources are either **held** or **available**

---

### âž• Vector Relation
- `A â‰¤ B` â‡¨ `A[i] â‰¤ B[i] âˆ€ i`

---

### âœ… Deadlock Detection Algorithm

```text
Initially, all processes are unmarked

1. Find an unmarked process Pi such that: R[i] â‰¤ A
2. If found:
   - Add C[i] to A (simulate Pi finishing)
   - Mark Pi as completed
   - Go back to step 1
3. If no such Pi exists:
   - Terminate
   - All *unmarked* processes are deadlocked
```

> âœ… Safe state â†’ all processes eventually get what they need  
> âŒ Deadlock â†’ some processes can't proceed even in worst-case allocation

---

### ðŸ’¡ Example

Given:
```
E = (4, 2, 3, 1)       # 4 Tape drives, 2 Plotters, 3 Scanners, 1 Camera
A = (2, 1, 0, 0)
C = [
  [0, 0, 1, 0],        # P1: Holds 1 scanner
  [2, 0, 0, 1],        # P2: Holds 2 tapes, 1 camera
  [0, 1, 2, 0]         # P3: Holds 1 plotter, 2 scanners
]
R = [
  [2, 0, 0, 1],        # P1: Needs 2 tapes + 1 camera
  [1, 0, 1, 0],        # P2: Needs 1 tape + 1 scanner
  [2, 1, 0, 0]         # P3: Needs 2 tapes + 1 plotter
]
```

#### ðŸ” Execution Simulation:
- P3 can run â†’ releases resources â†’  
  `A = (2, 2, 2, 0)`
- P2 can now run â†’ releases resources â†’  
  `A = (4, 2, 2, 1)`
- P1 can now run â†’ âœ… **No deadlock**

#### âŒ Deadlock Scenario:
If P3 requests an additional camera â†’ no process's request is â‰¤ A  
â†’ All blocked â†’ **deadlock**

---

### ðŸ•°ï¸ When to Run the Algorithm?

- On **every request** â†’ immediate detection, but costly
- At **regular intervals** (e.g., every `k` mins)
- When **CPU utilization** drops (may signal blocked processes)

---

### ðŸ§  Insight
This algorithm assumes:
- **All resource needs are known**
- **Processes do not release resources until they finish**
- Deadlock detection â‰  prevention â€” itâ€™s about identifying it when it happens

---
## â™»ï¸ 6.4.3 Recovery from Deadlock

---

### ðŸŽ¯ Objective
Once a deadlock is detected, the system must choose a strategy to break it and resume operation. **None are perfect**â€”each comes with trade-offs.

---

### ðŸ” 1. Recovery through Preemption

- **Definition**: Temporarily reclaim a resource from its current owner and reassign it.
- **Challenges**:
  - Not all resources are preemptable (e.g., you can't take away half-written data).
  - Manual intervention may be required (esp. in batch systems).
  - Risk of disrupting process consistency.

> ðŸ“¦ *Example*: 
> Laser printerâ€™s output could be paused, sheets set aside, and printer reassigned. Later, original process resumes with printer output queue restored.

- **When feasible**:
  - Resource usage is non-destructive or reversible.
  - The state of the process can tolerate loss or delay of the resource.

---

### ðŸ” 2. Recovery through Rollback

- **Definition**: Revert process to a previously saved state where it didnâ€™t own the resource.
- **Implementation**:
  - **Checkpointing**: Save memory, resource ownership, and execution state.
  - Create multiple checkpoints (not overwrite).
- **Rollback**:
  - Restart from an earlier checkpoint that predates acquisition of the contested resource.
  - **Side effect**: All work done after the checkpoint is lost (may result in duplicate output or computation).

> ðŸ§  Works best in systems where checkpoints are cheap and processes are stateless or repeatable.

---

### ðŸ” 3. Recovery through Killing Processes

- **Definition**: Terminate one or more processes to free up resources and break the cycle.
- **Strategies**:
  - Kill a process in the cycle directly.
  - Kill a non-deadlocked process that holds needed resources.
- **Considerations for selection**:
  - Can the process be **restarted safely**?
    - âœ”ï¸ *Compiler*: safe to kill and rerun.
    - âŒ *Database updater*: unsafe if partial progress leads to corruption.
  - Impact on user/system.
  - Resource release benefit.
  
> ðŸ“Œ **Important**: Prefer to kill processes whose operations are **idempotent** or easily recoverable.

---

### ðŸ§  Summary

| Method           | Pros                                | Cons                                                |
|------------------|--------------------------------------|-----------------------------------------------------|
| Preemption       | May allow smooth continuation        | Only works for certain resource types               |
| Rollback         | Non-destructive, reversible          | Loses progress; requires checkpointing infrastructure |
| Killing          | Simple and decisive                  | May cause data loss or user dissatisfaction         |

--- 
