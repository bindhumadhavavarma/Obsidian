
### ğŸ”’ Formal Definition

> A set of processes is **deadlocked** if each process is waiting for an event **that only another process in the set can cause**.

- No process in the set can proceed; all are waiting forever.
- Assumes:
  - Processes are **single-threaded**.
  - **No interrupts** (to prevent escape from blocked state).
- In most cases, the event is the **release of a resource** held by another process in the set.
- Applies to **both hardware and software resources**.

---

## âš ï¸ 6.2.1 Conditions for Resource Deadlocks

According to **Coffman et al. (1971)**, four conditions must hold *simultaneously* for a **resource deadlock** to occur:

1. **Mutual Exclusion**  
   Each resource is either assigned to exactly one process or is available.

2. **Hold and Wait**  
   Processes holding resources may also request new ones.

3. **No Preemption**  
   Resources cannot be forcibly taken from processes; they must be released voluntarily.

4. **Circular Wait**  
   A circular chain of processes exists, each waiting for a resource held by the next.

> ğŸ’¡ **Negating any one** of these prevents deadlocks. Each is linked to system-level resource policies.

---

## ğŸ” 6.2.2 Deadlock Modeling with Resource Allocation Graphs

Introduced by **Holt (1972)**.

### ğŸ“˜ Graph Structure

- **Nodes**:
  - Processes â†’ circles
  - Resources â†’ squares
- **Arcs**:
  - **Resource â Process** â†’ resource is held
  - **Process â Resource** â†’ resource is requested

### ğŸ§© Example (Fig. 6-6)

- (a) Resource R held by A â†’ R â A
- (b) B is waiting for S â†’ B â S
- (c) Deadlock:
  ```
  C â T â D â U â C  â†’ circular wait â‡’ deadlock
  ```

> ğŸ”„ **Cycle = Deadlock**, if each resource has a single instance.

---

## ğŸ§ª Modeling Example with Processes A, B, C

### ğŸ¯ Scenario

- Processes: A, B, C
- Resources: R, S, T

### ğŸª¢ Deadlock-Producing Request Sequence (Fig. 6-7dâ€“j)

1. Requests granted in a certain interleaving lead to all 3 processes blocking.
2. Result: circular wait â†’ **deadlock** in Fig. 6-7(j).

### âœ… Safe Alternative Sequence (Fig. 6-7kâ€“q)

- Suspend process B early.
- Run A and C safely first.
- After A and C finish, B can safely proceed.

> The **OS can prevent deadlock** by choosing which requests to grant or defer, based on resource state and process order.

---

## ğŸ› ï¸ Deadlock Handling Strategies

1. **Ignore the problem**  
   - Used in many simple systems (e.g., desktop OSes).

2. **Detection and Recovery**  
   - Allow deadlocks to happen, then detect and resolve.

3. **Dynamic Avoidance**  
   - Use algorithms to avoid unsafe states during resource allocation.

4. **Prevention**  
   - Structurally eliminate one of the four Coffman conditions.

> ğŸ“Œ These four approaches will be covered in detail in the upcoming sections.

---
## ğŸ¦¤ 6.3 The Ostrich Algorithm

### ğŸ’¡ Definition
- The **Ostrich Algorithm** handles deadlocks by **ignoring them**.
- Based on the idea of "burying your head in the sand and pretending nothing is wrong."

> ğŸ§  *Named humorously after the myth that ostriches ignore danger by burying their headsâ€”this is biologically inaccurate but metaphorically useful.*

---

### ğŸ‘¨â€ğŸ”¬ Mathematicians vs ğŸ‘· Engineers

- **Mathematicians**:
  - Demand rigorous guarantees â€” **deadlocks must be prevented at all costs**.
- **Engineers**:
  - Focus on **cost-benefit trade-offs**:
    - If **deadlocks are rare** (e.g., once every 5 years),
    - but **hardware crashes occur weekly**,
    - then eliminating deadlocks may not be **worth the performance cost**.

---

### ğŸ› ï¸ Real-World Example

- Consider an OS where a process calls `open()` on a physical device like:
  - a **3D scanner**
  - a **printer**
- If the device is busy, the **device driver** must choose an action:
  - **Block** the caller
  - **Return an error code**

#### ğŸ§© Potential Deadlock
- Process A opens the scanner.
- Process B opens the printer.
- A requests the printer, B requests the scanner â†’ **both block** â†’ deadlock.

> âš ï¸ Most operating systems **do not detect** this scenario.

---

### ğŸ“Œ When is this approach acceptable?

- **Deadlocks are very rare**.
- **System crashes or hardware failures** are more frequent.
- **User/admin intervention** (e.g. killing processes) is acceptable when deadlocks occur.
- Used by **many practical systems**, including versions of **UNIX**, **Linux**, and **Windows**.

> âœ… Simple to implement  
> âŒ No guarantees of safety or liveness  

---
