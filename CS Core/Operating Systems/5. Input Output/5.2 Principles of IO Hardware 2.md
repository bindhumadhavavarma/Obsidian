
## ðŸ›Žï¸ 5.1.5 Interrupts Revisited

### ðŸ”„ Terminology Clarification

| Term        | Triggered by      | Description |
|-------------|-------------------|-------------|
| **Trap**    | Program code       | Intentional, e.g., system calls. |
| **Fault**   | Program error      | Unintentional, e.g., divide by zero. |
| **Exception** | Program anomaly | Often used synonymously with fault. |
| **Interrupt** | Hardware device | Signal from an I/O device to the CPU. |

---

### âš™ï¸ How Hardware Interrupts Work

![[{8F5852CA-664C-4BBF-9155-2EB458090E69}.png]]
1. **Device completes I/O operation** â†’ sends signal via interrupt line on the bus.
2. **Interrupt controller** receives signal.
   - If no higher priority interrupt is active â†’ sends signal to CPU.
   - If another interrupt is being serviced â†’ queues the new one.
3. **Controller puts interrupt number** on the bus address lines.
4. **CPU uses this number as index into interrupt vector** â†’ jumps to interrupt service routine (ISR).

> Interrupts, traps, and faults converge at this point, using the same dispatch mechanism via interrupt vector.

---

### ðŸ§  Interrupt Vector Table
- A **lookup table** of ISR addresses.
- May be **hardwired** or **pointed to by a register**.
- Used to determine the **entry point of ISR** corresponding to each interrupt type.

---

### âœ… Acknowledging the Interrupt
- The ISR must acknowledge the interrupt by writing to the interrupt controller's port.
- This allows the controller to **issue the next interrupt**.
- **Delaying this step** helps avoid race conditions between multiple interrupts.

---

### ðŸ§© Saving Context: Where and What?

| Method           | Pros and Cons |
|------------------|---------------|
| **Internal Registers** | Fast but unsafe: new interrupt may overwrite state before itâ€™s saved. |
| **Process Stack** | Risky: stack may be invalid, lead to page faults. |
| **Kernel Stack** | Safer: typically pinned and legal, but may trigger MMU or TLB reloads, slowing response. |

> Minimum saved: **Program Counter (PC)**.  
> Maximum saved: **All CPU-visible + internal registers**.

---

### â— Challenges in Interrupt Handling

- **Invalid user stack pointer** during interrupt â†’ can cause fatal errors.
- **Page fault during stack push** (if on user stack) â†’ catastrophic.
- **Kernel stack switch** requires changing address space, may flush cache and TLB, **delays ISR**.
- **Dead time risk**: long delay if CPU can't quickly acknowledge the interrupt.

---

### ðŸ§­ Summary
- Interrupts provide a hardware mechanism for **asynchronous I/O signaling**.
- Careful coordination between hardware and software is required to **reliably and safely** handle them.
- **Performance trade-offs** exist in how and where state is saved and how promptly interrupts are acknowledged.

---
## âš¡ Precise and Imprecise Interrupts

### ðŸ§  Background
Older CPUs assumed that at the moment an **interrupt** occurred:
- All instructions before the PC had fully executed.
- No instruction beyond the PC had started.

This made interrupt handling simple and predictable. Modern CPUs complicate this due to:
- **Pipelining**: Instructions are in various execution stages.
- **Superscalar execution**: Instructions may execute out of order as micro-operations.

---

### ðŸŽ¯ Precise Interrupts

A **precise interrupt** ensures:
1. âœ… **PC is saved** in a known place.
2. âœ… All **instructions before the PC** have completed.
3. âœ… **No instruction after the PC** has executed.
4. âœ… The **state of the instruction at PC** is well defined.

ðŸ“Œ Even if later instructions started, **their effects must be undone** â†’ they are **transient**.

> Modern CPUs (e.g. x86) ensure this by rolling back transient effects and committing results in order.

#### ðŸ”„ Transient Execution
- Instructions beyond the PC may **speculatively execute** (e.g., due to branch prediction).
- If mispredicted or interrupted, results are discarded.
- However, side effects (like cache changes) may persist, which can **leak data** â†’ discussed in **Chapter 9**.

---

### âš ï¸ Imprecise Interrupts

An **imprecise interrupt** violates the above four conditions.

ðŸ“‰ At the time of interrupt:
- Some older instructions may not be finished.
- Some newer ones may be partly or fully executed.

ðŸ“š **OS consequences**:
- Difficult to determine which instructions executed.
- Must deal with a **messy, inconsistent CPU state**.
- Requires dumping huge internal CPU state to memory.
- **Restarting and recovery** is complex and slow.

> Example shown in **Fig. 5-6(b)** â€“ chaotic execution state near PC.

---

### ðŸ§© Trade-Offs

| Feature                  | Precise Interrupts                  | Imprecise Interrupts                   |
|--------------------------|--------------------------------------|-----------------------------------------|
| ðŸ› ï¸ Ease for OS           | Simple recovery                     | Complex, error-prone                     |
| ðŸš€ Performance impact     | Slower execution, more CPU logic    | Faster hardware, complex OS             |
| ðŸ§± Chip design           | More chip area for logic, less for cache | More efficient chip, faster in theory  |
| ðŸ” Security              | More predictable                    | Risk of **leaky transient effects**     |

> Some CPUs allow **only fatal traps** (e.g., divide-by-zero) to be imprecise.

---

### ðŸ’¡ Practical Strategies

- Some architectures allow **configuring interrupt precision** (via CPU bits).
- Precise interrupts are favored in **real-time systems** and **secure systems**.
- Imprecise interrupts may benefit **performance-centric embedded systems**.

---

